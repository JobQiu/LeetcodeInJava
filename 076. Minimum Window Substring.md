
public class Solution{
  public String minWindow(String s, String t){

      // 1. filter some cases
      if(s == null || t == null)
      return "";



      // 2. use an int array to store the count
      int[] dict = new int[128];


  }
}

---


https://leetcode.com/problems/minimum-window-substring/description/

class Solution {
    public String minWindow(String s, String t) {

      int[] map = new int[128];

      for(char c: s.toCharArray()) map[c]++;
      int start=0, end =0;
      while(end < s.length()){

        if(map[s.charAt(end++)]-- > 0) count-- ;
        // what does this mean,

        // end is the 0 at first, and after this end will move to right
        // map'a' >0 means we need it to satisfy, so count --

        while(count == 0){
          if(end - start < d){
            d = end - start;
            head = start;
          }
          if(map[s.charAt(begin++)]++ = 0)
            count++;
        }
      }

      return d == Integer.MAX_VALUE
      //


    }
}

public class Solution{
  public String minWindow(String s, String t) {




  }

}


so


for iterate the nums

## second time


```

/***
 * Input: S = "ADOBECODEBANC", T = "ABC"
 * Output: "BANC"
 **/

 class Solution {
     public String minWindow(String s, String t) {

         if(s == null || t == null || s.length() == 0 || t.length() == 0|| s.length() < t.length()){
           return "";
         }

         int[] tsetcount = new int[128];
         for(char c: t.toCharArray()){
             tsetcount[c-'A'] +=1;
         }

         HashSet<Character> tset = new HashSet();
         for(char c: t.toCharArray()){
           tset.add(c);
         } // in test example, it would be A B and C

         int[] charCount = new int[128];

         int count = tset.size(); // here it will be 3, every time we collect a new jewel, count --
         char[] schars = s.toCharArray(); // it's an array of s, ADOBECODEBANC
         int l = schars.length; // l = 13 i guess
         int start = 0;
         int end = 0;
         int result = Integer.MAX_VALUE;
         String res ="";

         // start end
         // ADOBEC
         // DOBECODEBA CODEBA ODEBA
         // ODEBANC BANC
         while(end<l){ // when will we stop this iteration
           // when end move forward, we add a new count in charCount;
           if(charCount[schars[end]-'A']++ < tsetcount[schars[end]-'A']){
             if(tset.contains(schars[end])){ // for AA, you should just count -- once
               count --;
             }
           }
           while(count == 0){
             int tempLen = end - start+1;
             if(result > tempLen){
               res = s.substring(start, end+1);
               result = tempLen;
             }

             if(charCount[schars[start]-'A']-- == 1){
               if(tset.contains(schars[start])){ // for AA, you should just count -- once
                 count++;
               }

             }

             if(tset.contains(schars[start])){ // for AA, you should just count -- once
                 if(charCount[schars[start]-'A']-- >0);
                     count++;
               }else{
                 charCount[schars[start]-'A']--;
             }

             start++;
             // remove a count from char count
           }
           end ++; // move on to the next char
         }

         return res; // end is not inclusive




     }
 }



```

```
class Solution {
    public String minWindow(String s, String t) {
        if (s == null || t == null) return "";
        // total number of character in p to be contained in s
        int countToBeContained = t.length(), minLen = Integer.MAX_VALUE, startIndex = -1;
        // calculate the number of each character to be contained in S
        int[] dict = new int[128];
        for (char c : t.toCharArray()) dict[c]++;

        int fast = 0, slow = 0;
        while (fast < s.length()) {
            // if need to be contained, include it and minus the counter
            if (dict[s.charAt(fast++)]-- > 0)
                countToBeContained--;

            // all included, move the slow pointer to minimize the window
            while (countToBeContained == 0) {
                // current window contains same number of the current character as in t, cannot move forward anymore
                if (dict[s.charAt(slow++)]++ == 0) countToBeContained++;

                // update minLen
                if (fast - slow + 1 < minLen) {
                    startIndex = slow - 1;
                    minLen = fast - slow + 1;
                }
            }
        }
        return startIndex == -1 ? "" : s.substring(startIndex, startIndex + minLen);
    }
}
```
