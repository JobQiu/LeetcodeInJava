Tree Problems, inorder, preorder,
DP, reuse the previous result.
DFS
BFS
BackStracking
Array, 2 pointers, swap
Matrix or Array, visited mark.
Map, or array as dictionaries.
Binary Search, insert
Array, the number is the index of another number
Queue,
Stack,
Trie
Linkedlist, find the start of loop,
Intervals,
Bit manipulation.
Divide by 0.


---

### 1. Tree Problems, inorder, preorder,

### 2. DP, reuse the previous result.

### 3. DFS

681. next closest time, give u a time, for example, 19:34, the closest time using the same numbers is 19:39.
So you can just use a 4-depth dfs to iterate all the possible situations to get the closest time. It's optimal.
I think you can also use BFS, since we need to iterate all the situations.
679. 24 Game, give u 4 numbers, for example, 4 1 8 7, if it's possible to get a 24 from them.
The basic idea is also iterate all the possible situations to see if it's possible.


### 4. BFS
### 5. Backtracking
### 6. Array, 2 pointers, swap
### 7. Matrix or Array, visited mark.
### 8. Map, or array as dictionaries.
### 9. Binary Search, insert
### 10. Array, the number is the index of another number
### 11. Queue,
### 12. Stack,
### 13. Trie
### 14. Linkedlist, find the start of loop,
### 15. Intervals,
### 16. Bit manipulation.
### 17. Divide by 0

----

The idea of this note, is to generalize all the problems I've solved, and build a checklist, so that every time I need to solve new problems, I can check if I've met some similar questions before.
