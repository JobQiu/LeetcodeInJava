```

public  List<Interval > merge(List<Interval> intervals){
  // 1. filter
  if(intervals.size() <=1){
    return intervals;
    } // end of if

  intervals.sort((i1,i2)-> Integer.compare(i1.start, i2.start));

  List<Interval> list = new LinkedList();

  int start = intervals.get(0).start;
  int end = intervals.get(0).end;

  for(Interval interval: intervals){

    if(interval.start <= end){
      end = Math.max(end, interval.end);
      } // end of if

    else{
      list.add(new Interval(start, end));
      start = interval.start;
      end = interval.end;

    }
  }

  list.add(new Interval(start, end));
  return list;

}


```


```


  public List<Interval> merge(List<Interval> intervals) {
    // 1. filter null and so on
    if(intervals == null || intervals.size()<=1){
      return intervals;
    }

    intervals.sort((i1, i2) -> Integer.compare(i1.start, i2.start));

    // 2. some variables here
    int start = intervals.get(0).start;
    int end = intervals.get(0).end;
    List<Interval> result = new ArrayList();

    for(int i = 1; i < intervals.size() ; i++){
      Interval temp = intervals.get(i);

      if(end>=temp.start){
        // 3. should merge here
        end = Math.max(temp.end,end);

      }else{
        // 4. the previous and the current interval doesnot overlap, we can save start and end as an interval into result
        result.add(new Interval(start, end));
        start = temp.start;
        end = temp.end;


      }

    }

          // 5. dont forget the last one
          result.add(new Interval(start,end));

          return result;

  }


```
